"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@visionz";
exports.ids = ["vendor-chunks/@visionz"];
exports.modules = {

/***/ "(ssr)/./node_modules/@visionz/upload-helper-react/dist/index.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@visionz/upload-helper-react/dist/index.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getVisionZFile: () => (/* binding */ getFileUrl),\n/* harmony export */   getVisionZFiles: () => (/* binding */ getFileUrlBulk),\n/* harmony export */   useVisionZMultipleUpload: () => (/* binding */ useVisionZMultipleUpload),\n/* harmony export */   useVisionZUpload: () => (/* binding */ useVisionZUpload)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/lib/axios.js\");\n// src/useUpload.ts\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _iterable_to_array_limit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _object_spread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _sliced_to_array(arr, i) {\n    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nfunction _ts_generator(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\n\n// src/clientApiFunctions.ts\n\nvar requestUpload = function() {\n    var _ref = _async_to_generator(function(apiPath, req) {\n        return _ts_generator(this, function(_state) {\n            return [\n                2,\n                axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(apiPath, _object_spread({\n                    type: \"requestUpload\" /* RequestUpload */ \n                }, req)).then(function(res) {\n                    return res.data;\n                })\n            ];\n        });\n    });\n    return function requestUpload(apiPath, req) {\n        return _ref.apply(this, arguments);\n    };\n}();\nvar notifyUploadComplete = function() {\n    var _ref = _async_to_generator(function(apiPath, req) {\n        return _ts_generator(this, function(_state) {\n            return [\n                2,\n                axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(apiPath, _object_spread({\n                    type: \"notifyUploadComplete\" /* NotifyUploadComplete */ \n                }, req)).then(function(res) {\n                    return res.data;\n                })\n            ];\n        });\n    });\n    return function notifyUploadComplete(apiPath, req) {\n        return _ref.apply(this, arguments);\n    };\n}();\nvar getFileUrl = function() {\n    var _ref = _async_to_generator(function(apiPath, uploadId) {\n        return _ts_generator(this, function(_state) {\n            return [\n                2,\n                axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(apiPath, {\n                    type: \"getFileUrl\" /* GetFileUrl */ ,\n                    uploadId: uploadId\n                }).then(function(res) {\n                    return res.data.fileUrl;\n                })\n            ];\n        });\n    });\n    return function getFileUrl(apiPath, uploadId) {\n        return _ref.apply(this, arguments);\n    };\n}();\nvar getFileUrlBulk = function() {\n    var _ref = _async_to_generator(function(apiPath, uploadIds) {\n        var getFilePromises, i, batchIds;\n        return _ts_generator(this, function(_state) {\n            getFilePromises = [];\n            for(i = 0; i < uploadIds.length; i = i + 100){\n                batchIds = uploadIds.slice(i, i + 100);\n                getFilePromises.push(axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(apiPath, {\n                    type: \"getFileUrlBulk\" /* GetFileUrlBulk */ ,\n                    uploadIds: batchIds\n                }).then(function(res) {\n                    return res.data;\n                }));\n            }\n            return [\n                2,\n                Promise.all(getFilePromises).then(function(resolved) {\n                    return resolved.flat();\n                })\n            ];\n        });\n    });\n    return function getFileUrlBulk(apiPath, uploadIds) {\n        return _ref.apply(this, arguments);\n    };\n}();\n// src/useUpload.ts\n\nvar useVisionZUpload = function(apiPath) {\n    var _useState = _sliced_to_array((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false), 2), isUploading = _useState[0], setIsUploading = _useState[1];\n    var _useState1 = _sliced_to_array((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), 2), selectedFile = _useState1[0], setSelectedFile = _useState1[1];\n    var onFileChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(file) {\n        if (isUploading) {\n            throw new Error(\"An upload is in progress\");\n        }\n        setSelectedFile(file || null);\n    }, [\n        isUploading\n    ]);\n    var uploadSelectedFile = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(/*#__PURE__*/ _async_to_generator(function() {\n        var name, size, _ref, pendingUploadId, preSignedUrl;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    if (isUploading) {\n                        throw new Error(\"An upload is in progress\");\n                    }\n                    if (!selectedFile) {\n                        throw new Error(\"No file is selected\");\n                    }\n                    _state.label = 1;\n                case 1:\n                    _state.trys.push([\n                        1,\n                        ,\n                        5,\n                        6\n                    ]);\n                    setIsUploading(true);\n                    name = selectedFile.name, size = selectedFile.size;\n                    return [\n                        4,\n                        requestUpload(apiPath, {\n                            fileName: name,\n                            fileSizeInByte: size\n                        })\n                    ];\n                case 2:\n                    _ref = _state.sent(), pendingUploadId = _ref.pendingUploadId, preSignedUrl = _ref.preSignedUrl;\n                    return [\n                        4,\n                        axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].put(preSignedUrl, selectedFile)\n                    ];\n                case 3:\n                    _state.sent();\n                    return [\n                        4,\n                        notifyUploadComplete(apiPath, {\n                            pendingUploadId: pendingUploadId\n                        })\n                    ];\n                case 4:\n                    return [\n                        2,\n                        _state.sent().uploadId\n                    ];\n                case 5:\n                    setSelectedFile(null);\n                    setIsUploading(false);\n                    return [\n                        7\n                    ];\n                case 6:\n                    return [\n                        2\n                    ];\n            }\n        });\n    }), [\n        apiPath,\n        isUploading,\n        selectedFile\n    ]);\n    return {\n        onFileChange: onFileChange,\n        uploadSelectedFile: uploadSelectedFile,\n        isUploading: isUploading,\n        selectedFile: selectedFile\n    };\n};\n// src/useMultipleUpload.ts\n\n\nvar useVisionZMultipleUpload = function(apiPath) {\n    var _useState2 = _sliced_to_array((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false), 2), isUploading = _useState2[0], setIsUploading = _useState2[1];\n    var _useState21 = _sliced_to_array((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), 2), selectedFiles = _useState21[0], setSelectedFiles = _useState21[1];\n    var onFilesChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(files) {\n        if (isUploading) {\n            throw new Error(\"An upload is in progress\");\n        }\n        setSelectedFiles(files || []);\n    }, [\n        isUploading\n    ]);\n    var uploadSelectedFiles = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(/*#__PURE__*/ _async_to_generator(function() {\n        var uploadPromises;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    if (isUploading) {\n                        throw new Error(\"An upload is in progress\");\n                    }\n                    if (!selectedFiles || !selectedFiles.length) {\n                        throw new Error(\"No file is selected\");\n                    }\n                    _state.label = 1;\n                case 1:\n                    _state.trys.push([\n                        1,\n                        ,\n                        3,\n                        4\n                    ]);\n                    setIsUploading(true);\n                    uploadPromises = selectedFiles.map(function() {\n                        var _ref = _async_to_generator(function(selectedFile) {\n                            var name, size, _ref, pendingUploadId, preSignedUrl;\n                            return _ts_generator(this, function(_state) {\n                                switch(_state.label){\n                                    case 0:\n                                        name = selectedFile.name, size = selectedFile.size;\n                                        return [\n                                            4,\n                                            requestUpload(apiPath, {\n                                                fileName: name,\n                                                fileSizeInByte: size\n                                            })\n                                        ];\n                                    case 1:\n                                        _ref = _state.sent(), pendingUploadId = _ref.pendingUploadId, preSignedUrl = _ref.preSignedUrl;\n                                        return [\n                                            4,\n                                            axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].put(preSignedUrl, selectedFile)\n                                        ];\n                                    case 2:\n                                        _state.sent();\n                                        return [\n                                            4,\n                                            notifyUploadComplete(apiPath, {\n                                                pendingUploadId: pendingUploadId\n                                            })\n                                        ];\n                                    case 3:\n                                        return [\n                                            2,\n                                            _state.sent().uploadId\n                                        ];\n                                }\n                            });\n                        });\n                        return function(selectedFile) {\n                            return _ref.apply(this, arguments);\n                        };\n                    }());\n                    return [\n                        4,\n                        Promise.all(uploadPromises)\n                    ];\n                case 2:\n                    return [\n                        2,\n                        _state.sent()\n                    ];\n                case 3:\n                    setSelectedFiles([]);\n                    setIsUploading(false);\n                    return [\n                        7\n                    ];\n                case 4:\n                    return [\n                        2\n                    ];\n            }\n        });\n    }), [\n        apiPath,\n        isUploading,\n        selectedFiles\n    ]);\n    return {\n        onFilesChange: onFilesChange,\n        uploadSelectedFiles: uploadSelectedFiles,\n        isUploading: isUploading,\n        selectedFiles: selectedFiles\n    };\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpc2lvbnovdXBsb2FkLWhlbHBlci1yZWFjdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0JBQStCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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NkNBQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VIO0FBQ3ZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVhcm5pbmctbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B2aXNpb256L3VwbG9hZC1oZWxwZXItcmVhY3QvZGlzdC9pbmRleC5tanM/ODNjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXNlVXBsb2FkLnRzXG5mdW5jdGlvbiBfYXJyYXlfbGlrZV90b19hcnJheShhcnIsIGxlbikge1xuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKWFycjJbaV0gPSBhcnJbaV07XG4gICAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfYXJyYXlfd2l0aF9ob2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9hc3luY190b19nZW5lcmF0b3IoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gX2RlZmluZV9wcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlX3RvX2FycmF5X2xpbWl0KGFyciwgaSkge1xuICAgIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcbiAgICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX3MsIF9lO1xuICAgIHRyeSB7XG4gICAgICAgIGZvcihfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSl7XG4gICAgICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuICAgICAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kID0gdHJ1ZTtcbiAgICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5e1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfYXJyO1xufVxuZnVuY3Rpb24gX25vbl9pdGVyYWJsZV9yZXN0KCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9vYmplY3Rfc3ByZWFkKHRhcmdldCkge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9zbGljZWRfdG9fYXJyYXkoYXJyLCBpKSB7XG4gICAgcmV0dXJuIF9hcnJheV93aXRoX2hvbGVzKGFycikgfHwgX2l0ZXJhYmxlX3RvX2FycmF5X2xpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkX2l0ZXJhYmxlX3RvX2FycmF5KGFyciwgaSkgfHwgX25vbl9pdGVyYWJsZV9yZXN0KCk7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkobywgbWluTGVuKSB7XG4gICAgaWYgKCFvKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5X2xpa2VfdG9fYXJyYXkobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5KG8sIG1pbkxlbik7XG59XG5mdW5jdGlvbiBfdHNfZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgZiwgeSwgdCwgZywgXyA9IHtcbiAgICAgICAgbGFiZWw6IDAsXG4gICAgICAgIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdO1xuICAgICAgICAgICAgcmV0dXJuIHRbMV07XG4gICAgICAgIH0sXG4gICAgICAgIHRyeXM6IFtdLFxuICAgICAgICBvcHM6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gZyA9IHtcbiAgICAgICAgbmV4dDogdmVyYigwKSxcbiAgICAgICAgXCJ0aHJvd1wiOiB2ZXJiKDEpLFxuICAgICAgICBcInJldHVyblwiOiB2ZXJiKDIpXG4gICAgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcChbXG4gICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICB2XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlKF8pdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbXG4gICAgICAgICAgICAgICAgb3BbMF0gJiAyLFxuICAgICAgICAgICAgICAgIHQudmFsdWVcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBzd2l0Y2gob3BbMF0pe1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3BbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICAgIG9wID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9wID0gW1xuICAgICAgICAgICAgICAgIDYsXG4gICAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICBmID0gdCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCxcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG59XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbi8vIHNyYy9jbGllbnRBcGlGdW5jdGlvbnMudHNcbmltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcbnZhciByZXF1ZXN0VXBsb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF9yZWYgPSBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKGFwaVBhdGgsIHJlcSkge1xuICAgICAgICByZXR1cm4gX3RzX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICBheGlvcy5wb3N0KGFwaVBhdGgsIF9vYmplY3Rfc3ByZWFkKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZXF1ZXN0VXBsb2FkXCIgLyogUmVxdWVzdFVwbG9hZCAqLyBcbiAgICAgICAgICAgICAgICB9LCByZXEpKS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmRhdGE7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0VXBsb2FkKGFwaVBhdGgsIHJlcSkge1xuICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59KCk7XG52YXIgbm90aWZ5VXBsb2FkQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3JlZiA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24oYXBpUGF0aCwgcmVxKSB7XG4gICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgIGF4aW9zLnBvc3QoYXBpUGF0aCwgX29iamVjdF9zcHJlYWQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm5vdGlmeVVwbG9hZENvbXBsZXRlXCIgLyogTm90aWZ5VXBsb2FkQ29tcGxldGUgKi8gXG4gICAgICAgICAgICAgICAgfSwgcmVxKSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gbm90aWZ5VXBsb2FkQ29tcGxldGUoYXBpUGF0aCwgcmVxKSB7XG4gICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn0oKTtcbnZhciBnZXRGaWxlVXJsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF9yZWYgPSBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKGFwaVBhdGgsIHVwbG9hZElkKSB7XG4gICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgIGF4aW9zLnBvc3QoYXBpUGF0aCwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImdldEZpbGVVcmxcIiAvKiBHZXRGaWxlVXJsICovICxcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkSWQ6IHVwbG9hZElkXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhLmZpbGVVcmw7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiBnZXRGaWxlVXJsKGFwaVBhdGgsIHVwbG9hZElkKSB7XG4gICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn0oKTtcbnZhciBnZXRGaWxlVXJsQnVsayA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfcmVmID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbihhcGlQYXRoLCB1cGxvYWRJZHMpIHtcbiAgICAgICAgdmFyIGdldEZpbGVQcm9taXNlcywgaSwgYmF0Y2hJZHM7XG4gICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgZ2V0RmlsZVByb21pc2VzID0gW107XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCB1cGxvYWRJZHMubGVuZ3RoOyBpID0gaSArIDEwMCl7XG4gICAgICAgICAgICAgICAgYmF0Y2hJZHMgPSB1cGxvYWRJZHMuc2xpY2UoaSwgaSArIDEwMCk7XG4gICAgICAgICAgICAgICAgZ2V0RmlsZVByb21pc2VzLnB1c2goYXhpb3MucG9zdChhcGlQYXRoLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZ2V0RmlsZVVybEJ1bGtcIiAvKiBHZXRGaWxlVXJsQnVsayAqLyAsXG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZElkczogYmF0Y2hJZHNcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmRhdGE7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKGdldEZpbGVQcm9taXNlcykudGhlbihmdW5jdGlvbihyZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQuZmxhdCgpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZ2V0RmlsZVVybEJ1bGsoYXBpUGF0aCwgdXBsb2FkSWRzKSB7XG4gICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn0oKTtcbi8vIHNyYy91c2VVcGxvYWQudHNcbmltcG9ydCBheGlvczIgZnJvbSBcImF4aW9zXCI7XG52YXIgdXNlVmlzaW9uWlVwbG9hZCA9IGZ1bmN0aW9uKGFwaVBhdGgpIHtcbiAgICB2YXIgX3VzZVN0YXRlID0gX3NsaWNlZF90b19hcnJheSh1c2VTdGF0ZShmYWxzZSksIDIpLCBpc1VwbG9hZGluZyA9IF91c2VTdGF0ZVswXSwgc2V0SXNVcGxvYWRpbmcgPSBfdXNlU3RhdGVbMV07XG4gICAgdmFyIF91c2VTdGF0ZTEgPSBfc2xpY2VkX3RvX2FycmF5KHVzZVN0YXRlKG51bGwpLCAyKSwgc2VsZWN0ZWRGaWxlID0gX3VzZVN0YXRlMVswXSwgc2V0U2VsZWN0ZWRGaWxlID0gX3VzZVN0YXRlMVsxXTtcbiAgICB2YXIgb25GaWxlQ2hhbmdlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICBpZiAoaXNVcGxvYWRpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIHVwbG9hZCBpcyBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRTZWxlY3RlZEZpbGUoZmlsZSB8fCBudWxsKTtcbiAgICB9LCBbXG4gICAgICAgIGlzVXBsb2FkaW5nXG4gICAgXSk7XG4gICAgdmFyIHVwbG9hZFNlbGVjdGVkRmlsZSA9IHVzZUNhbGxiYWNrKC8qI19fUFVSRV9fKi8gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5hbWUsIHNpemUsIF9yZWYsIHBlbmRpbmdVcGxvYWRJZCwgcHJlU2lnbmVkVXJsO1xuICAgICAgICByZXR1cm4gX3RzX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfc3RhdGUpIHtcbiAgICAgICAgICAgIHN3aXRjaChfc3RhdGUubGFiZWwpe1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVXBsb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiB1cGxvYWQgaXMgaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RlZEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZpbGUgaXMgc2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9zdGF0ZS50cnlzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICA2XG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBzZXRJc1VwbG9hZGluZyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHNlbGVjdGVkRmlsZS5uYW1lLCBzaXplID0gc2VsZWN0ZWRGaWxlLnNpemU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFVwbG9hZChhcGlQYXRoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVNpemVJbkJ5dGU6IHNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBfcmVmID0gX3N0YXRlLnNlbnQoKSwgcGVuZGluZ1VwbG9hZElkID0gX3JlZi5wZW5kaW5nVXBsb2FkSWQsIHByZVNpZ25lZFVybCA9IF9yZWYucHJlU2lnbmVkVXJsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aW9zMi5wdXQocHJlU2lnbmVkVXJsLCBzZWxlY3RlZEZpbGUpXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmeVVwbG9hZENvbXBsZXRlKGFwaVBhdGgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nVXBsb2FkSWQ6IHBlbmRpbmdVcGxvYWRJZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKS51cGxvYWRJZFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRGaWxlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBzZXRJc1VwbG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICA3XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KSwgW1xuICAgICAgICBhcGlQYXRoLFxuICAgICAgICBpc1VwbG9hZGluZyxcbiAgICAgICAgc2VsZWN0ZWRGaWxlXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb25GaWxlQ2hhbmdlOiBvbkZpbGVDaGFuZ2UsXG4gICAgICAgIHVwbG9hZFNlbGVjdGVkRmlsZTogdXBsb2FkU2VsZWN0ZWRGaWxlLFxuICAgICAgICBpc1VwbG9hZGluZzogaXNVcGxvYWRpbmcsXG4gICAgICAgIHNlbGVjdGVkRmlsZTogc2VsZWN0ZWRGaWxlXG4gICAgfTtcbn07XG4vLyBzcmMvdXNlTXVsdGlwbGVVcGxvYWQudHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMiwgdXNlU3RhdGUgYXMgdXNlU3RhdGUyIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgYXhpb3MzIGZyb20gXCJheGlvc1wiO1xudmFyIHVzZVZpc2lvblpNdWx0aXBsZVVwbG9hZCA9IGZ1bmN0aW9uKGFwaVBhdGgpIHtcbiAgICB2YXIgX3VzZVN0YXRlMiA9IF9zbGljZWRfdG9fYXJyYXkodXNlU3RhdGUyKGZhbHNlKSwgMiksIGlzVXBsb2FkaW5nID0gX3VzZVN0YXRlMlswXSwgc2V0SXNVcGxvYWRpbmcgPSBfdXNlU3RhdGUyWzFdO1xuICAgIHZhciBfdXNlU3RhdGUyMSA9IF9zbGljZWRfdG9fYXJyYXkodXNlU3RhdGUyKFtdKSwgMiksIHNlbGVjdGVkRmlsZXMgPSBfdXNlU3RhdGUyMVswXSwgc2V0U2VsZWN0ZWRGaWxlcyA9IF91c2VTdGF0ZTIxWzFdO1xuICAgIHZhciBvbkZpbGVzQ2hhbmdlID0gdXNlQ2FsbGJhY2syKGZ1bmN0aW9uKGZpbGVzKSB7XG4gICAgICAgIGlmIChpc1VwbG9hZGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gdXBsb2FkIGlzIGluIHByb2dyZXNzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHNldFNlbGVjdGVkRmlsZXMoZmlsZXMgfHwgW10pO1xuICAgIH0sIFtcbiAgICAgICAgaXNVcGxvYWRpbmdcbiAgICBdKTtcbiAgICB2YXIgdXBsb2FkU2VsZWN0ZWRGaWxlcyA9IHVzZUNhbGxiYWNrMigvKiNfX1BVUkVfXyovIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1cGxvYWRQcm9taXNlcztcbiAgICAgICAgcmV0dXJuIF90c19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX3N0YXRlKSB7XG4gICAgICAgICAgICBzd2l0Y2goX3N0YXRlLmxhYmVsKXtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1VwbG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gdXBsb2FkIGlzIGluIHByb2dyZXNzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0ZWRGaWxlcyB8fCAhc2VsZWN0ZWRGaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZpbGUgaXMgc2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9zdGF0ZS50cnlzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICA0XG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBzZXRJc1VwbG9hZGluZyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkUHJvbWlzZXMgPSBzZWxlY3RlZEZpbGVzLm1hcChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbihzZWxlY3RlZEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSwgc2l6ZSwgX3JlZiwgcGVuZGluZ1VwbG9hZElkLCBwcmVTaWduZWRVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90c19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX3N0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaChfc3RhdGUubGFiZWwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBzZWxlY3RlZEZpbGUubmFtZSwgc2l6ZSA9IHNlbGVjdGVkRmlsZS5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RVcGxvYWQoYXBpUGF0aCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlU2l6ZUluQnl0ZTogc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9zdGF0ZS5zZW50KCksIHBlbmRpbmdVcGxvYWRJZCA9IF9yZWYucGVuZGluZ1VwbG9hZElkLCBwcmVTaWduZWRVcmwgPSBfcmVmLnByZVNpZ25lZFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlvczMucHV0KHByZVNpZ25lZFVybCwgc2VsZWN0ZWRGaWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZnlVcGxvYWRDb21wbGV0ZShhcGlQYXRoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nVXBsb2FkSWQ6IHBlbmRpbmdVcGxvYWRJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKS51cGxvYWRJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNlbGVjdGVkRmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHVwbG9hZFByb21pc2VzKVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZEZpbGVzKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0SXNVcGxvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgN1xuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSksIFtcbiAgICAgICAgYXBpUGF0aCxcbiAgICAgICAgaXNVcGxvYWRpbmcsXG4gICAgICAgIHNlbGVjdGVkRmlsZXNcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvbkZpbGVzQ2hhbmdlOiBvbkZpbGVzQ2hhbmdlLFxuICAgICAgICB1cGxvYWRTZWxlY3RlZEZpbGVzOiB1cGxvYWRTZWxlY3RlZEZpbGVzLFxuICAgICAgICBpc1VwbG9hZGluZzogaXNVcGxvYWRpbmcsXG4gICAgICAgIHNlbGVjdGVkRmlsZXM6IHNlbGVjdGVkRmlsZXNcbiAgICB9O1xufTtcbmV4cG9ydCB7IGdldEZpbGVVcmwgYXMgZ2V0VmlzaW9uWkZpbGUsIGdldEZpbGVVcmxCdWxrIGFzIGdldFZpc2lvblpGaWxlcywgdXNlVmlzaW9uWk11bHRpcGxlVXBsb2FkLCB1c2VWaXNpb25aVXBsb2FkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@visionz/upload-helper-react/dist/index.mjs\n");

/***/ })

};
;